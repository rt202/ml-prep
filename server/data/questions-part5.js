// Part 5: Delivery/Operations, AI Systems Implementation, Production Problem Solving
export const questionsPart5 = [
  // ====== UNIT: delivery-operations ======
  // Lesson: ci-cd-procedures
  {
    id: 'do-cicd-1',
    text: 'What is the main purpose of running tests in a CI pipeline before merge?',
    options: ['To increase server usage', 'To catch regressions early and reduce production risk', 'To avoid code reviews', 'To replace monitoring'],
    correctAnswer: 1,
    explanation: 'CI test gates reduce the chance of broken code reaching production by validating behavior before merge.',
    difficulty: 'easy',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'industry_practice',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'delivery-operations',
    lessonId: 'ci-cd-procedures',
  },
  {
    id: 'do-cicd-2',
    text: 'A useful CI optimization for large repositories is:',
    options: ['Re-running every job on every commit', 'Skipping all tests on feature branches', 'Running changed-scope tests first and full suite on merge', 'Disabling linting permanently'],
    correctAnswer: 2,
    explanation: 'Scoped checks on PRs and full validation on merge keeps feedback fast while preserving reliability.',
    difficulty: 'medium',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'industry_practice',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'delivery-operations',
    lessonId: 'ci-cd-procedures',
  },
  {
    id: 'do-cicd-3',
    text: 'Why should secrets be injected at runtime in CI/CD rather than hardcoded in source?',
    options: ['It makes logs easier to read', 'It prevents accidental credential leaks and simplifies rotation', 'It improves UI performance', 'It removes the need for audits'],
    correctAnswer: 1,
    explanation: 'Runtime secret management lowers leakage risk and supports secure rotation and access control.',
    difficulty: 'medium',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'industry_practice',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'delivery-operations',
    lessonId: 'ci-cd-procedures',
  },
  {
    id: 'do-cicd-4',
    text: 'Which policy best protects the main branch in a collaborative team?',
    options: ['Direct pushes by anyone', 'Required reviews and passing checks before merge', 'Merge without tests for urgent features', 'Only commit messages are validated'],
    correctAnswer: 1,
    explanation: 'Branch protection with review and CI checks is a standard reliability safeguard.',
    difficulty: 'easy',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'industry_practice',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'delivery-operations',
    lessonId: 'ci-cd-procedures',
  },
  {
    id: 'do-cicd-5',
    text: 'What is the key value of artifact versioning in a release pipeline?',
    options: ['It removes the need for logs', 'It enables reproducible builds and rollback confidence', 'It guarantees zero incidents', 'It replaces QA testing'],
    correctAnswer: 1,
    explanation: 'Versioned artifacts make deployments traceable, reproducible, and easier to roll back safely.',
    difficulty: 'hard',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'industry_practice',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'delivery-operations',
    lessonId: 'ci-cd-procedures',
  },

  // Lesson: deployment-strategies
  {
    id: 'do-deploy-1',
    text: 'In blue-green deployment, traffic is switched between:',
    options: ['Two identical production environments', 'Two different code branches', 'Two monitoring dashboards', 'Two databases with different schemas'],
    correctAnswer: 0,
    explanation: 'Blue-green keeps two live environments so cutover and rollback are quick and controlled.',
    difficulty: 'easy',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'industry_practice',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'delivery-operations',
    lessonId: 'deployment-strategies',
  },
  {
    id: 'do-deploy-2',
    text: 'Canary releases are primarily used to:',
    options: ['Reduce build time', 'Gradually expose changes to a small audience and monitor impact', 'Eliminate feature flags', 'Avoid automated tests'],
    correctAnswer: 1,
    explanation: 'Canary deploys reduce blast radius by validating new behavior on limited traffic before full rollout.',
    difficulty: 'easy',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'industry_practice',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'delivery-operations',
    lessonId: 'deployment-strategies',
  },
  {
    id: 'do-deploy-3',
    text: 'A safe rollback plan should be prepared:',
    options: ['Only after a failed deployment', 'Before deployment with validated rollback steps', 'Only for major releases', 'Only when a customer complains'],
    correctAnswer: 1,
    explanation: 'Rollback readiness must exist before release to minimize downtime during incidents.',
    difficulty: 'medium',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'industry_practice',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'delivery-operations',
    lessonId: 'deployment-strategies',
  },
  {
    id: 'do-deploy-4',
    text: 'What is the best first response if post-deploy error rates spike?',
    options: ['Ignore alerts for 30 minutes', 'Scale CPU immediately without investigation', 'Pause rollout and compare key telemetry to baseline', 'Delete recent logs'],
    correctAnswer: 2,
    explanation: 'Pausing rollout and evaluating baseline deviations prevents wider impact and guides triage.',
    difficulty: 'hard',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'industry_practice',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'delivery-operations',
    lessonId: 'deployment-strategies',
  },
  {
    id: 'do-deploy-5',
    text: 'Feature flags in deployment are most useful for:',
    options: ['Replacing source control', 'Decoupling code release from feature exposure', 'Avoiding observability setup', 'Disabling testing'],
    correctAnswer: 1,
    explanation: 'Feature flags let teams ship safely and control exposure without redeploying.',
    difficulty: 'medium',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'industry_practice',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'delivery-operations',
    lessonId: 'deployment-strategies',
  },

  // ====== UNIT: ai-systems-implementation ======
  // Lesson: model-ops-patterns
  {
    id: 'ai-impl-1',
    text: 'When choosing between a larger and smaller model for production, a key tradeoff is:',
    options: ['Color scheme vs uptime', 'Latency/cost vs capability/quality', 'Branch naming vs test coverage', 'CPU type vs code comments'],
    correctAnswer: 1,
    explanation: 'Model selection balances response quality with serving latency, throughput, and cost constraints.',
    difficulty: 'easy',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'ai_implementation',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'ai-systems-implementation',
    lessonId: 'model-ops-patterns',
  },
  {
    id: 'ai-impl-2',
    text: 'A practical way to compare new model versions in production-like conditions is:',
    options: ['A/B or shadow testing with shared evaluation criteria', 'Asking only one internal reviewer', 'Deploying all versions to all users at once', 'Skipping offline evaluation entirely'],
    correctAnswer: 0,
    explanation: 'Controlled experiments with clear metrics reduce risk and support objective model upgrades.',
    difficulty: 'medium',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'ai_implementation',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'ai-systems-implementation',
    lessonId: 'model-ops-patterns',
  },
  {
    id: 'ai-impl-3',
    text: 'For stable AI behavior in production, one important control is:',
    options: ['Prompt and response versioning with evaluation tracking', 'Frequent manual server restarts', 'Randomly rotating output formats', 'Removing all guardrails'],
    correctAnswer: 0,
    explanation: 'Versioned prompts/configs plus tracked evaluations improve reproducibility and debugging.',
    difficulty: 'medium',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'ai_implementation',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'ai-systems-implementation',
    lessonId: 'model-ops-patterns',
  },
  {
    id: 'ai-impl-4',
    text: 'Why is output schema validation useful for LLM features?',
    options: ['It speeds up GPU clocks', 'It catches malformed outputs before downstream failures', 'It guarantees perfect model reasoning', 'It replaces user feedback'],
    correctAnswer: 1,
    explanation: 'Schema checks prevent malformed data from breaking dependent systems and workflows.',
    difficulty: 'hard',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'ai_implementation',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'ai-systems-implementation',
    lessonId: 'model-ops-patterns',
  },
  {
    id: 'ai-impl-5',
    text: 'A robust fallback strategy for AI endpoints usually includes:',
    options: ['No retries and no timeouts', 'Retries, graceful degradation, and deterministic fallback paths', 'Only larger prompts', 'Ignoring provider outages'],
    correctAnswer: 1,
    explanation: 'Fallbacks preserve user experience during latency spikes or provider failures.',
    difficulty: 'hard',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'ai_implementation',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'ai-systems-implementation',
    lessonId: 'model-ops-patterns',
  },

  // Lesson: agents-context-mcp
  {
    id: 'ai-acm-1',
    text: 'In agent systems, tool use should generally be:',
    options: ['Unrestricted for all users', 'Constrained by permissions and explicit policies', 'Disabled in production always', 'Randomized to improve creativity'],
    correctAnswer: 1,
    explanation: 'Policy and permission boundaries reduce misuse and security risks.',
    difficulty: 'medium',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'ai_implementation',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'ai-systems-implementation',
    lessonId: 'agents-context-mcp',
  },
  {
    id: 'ai-acm-2',
    text: 'A common benefit of MCP-style integrations is:',
    options: ['Directly replacing all databases', 'Standardized access to external tools and context sources', 'Eliminating authentication needs', 'Removing the need for observability'],
    correctAnswer: 1,
    explanation: 'Standardized tool interfaces simplify integration and governance across context providers.',
    difficulty: 'easy',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'ai_implementation',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'ai-systems-implementation',
    lessonId: 'agents-context-mcp',
  },
  {
    id: 'ai-acm-3',
    text: 'Context window management is important because:',
    options: ['Models ignore all long prompts', 'Too much low-quality context can degrade answer quality and cost', 'It only matters for image models', 'It has no effect after deployment'],
    correctAnswer: 1,
    explanation: 'Selecting relevant context improves precision while controlling latency and token cost.',
    difficulty: 'medium',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'ai_implementation',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'ai-systems-implementation',
    lessonId: 'agents-context-mcp',
  },
  {
    id: 'ai-acm-4',
    text: 'For semantic retrieval quality, what usually helps most?',
    options: ['Bigger UI buttons', 'Consistent chunking strategy plus relevance evaluation', 'Disabling metadata', 'Using one giant document chunk'],
    correctAnswer: 1,
    explanation: 'Good chunking and relevance evaluation are core drivers of retrieval quality.',
    difficulty: 'hard',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'ai_implementation',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'ai-systems-implementation',
    lessonId: 'agents-context-mcp',
  },
  {
    id: 'ai-acm-5',
    text: 'An effective multi-agent system should include:',
    options: ['Shared responsibility boundaries and handoff contracts', 'No orchestration layer', 'A single prompt with no state', 'Only one permission model for every task'],
    correctAnswer: 0,
    explanation: 'Clear task ownership and handoff protocols reduce duplication, conflicts, and errors.',
    difficulty: 'hard',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'ai_implementation',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'ai-systems-implementation',
    lessonId: 'agents-context-mcp',
  },

  // ====== UNIT: production-problem-solving ======
  // Lesson: reliability-incident-response
  {
    id: 'pps-rel-1',
    text: 'During an active incident, the first priority is typically to:',
    options: ['Write the postmortem immediately', 'Restore service safely and reduce user impact', 'Refactor code architecture', 'Start a new feature release'],
    correctAnswer: 1,
    explanation: 'Incident response prioritizes mitigation and user impact reduction before deep root-cause analysis.',
    difficulty: 'easy',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'real_world_execution',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'production-problem-solving',
    lessonId: 'reliability-incident-response',
  },
  {
    id: 'pps-rel-2',
    text: 'Which signal is best for alerting on user-facing reliability?',
    options: ['Total number of commits', 'SLI/SLO metrics such as error rate, latency, and availability', 'Team calendar utilization', 'Average meeting duration'],
    correctAnswer: 1,
    explanation: 'SLI/SLO metrics map directly to user experience and service reliability.',
    difficulty: 'medium',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'real_world_execution',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'production-problem-solving',
    lessonId: 'reliability-incident-response',
  },
  {
    id: 'pps-rel-3',
    text: 'A blameless postmortem mainly aims to:',
    options: ['Find one person to punish', 'Document causes, impacts, and preventative actions', 'Avoid any mention of failures', 'Skip action items to move faster'],
    correctAnswer: 1,
    explanation: 'Blameless postmortems improve systems and processes through actionable learning.',
    difficulty: 'easy',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'real_world_execution',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'production-problem-solving',
    lessonId: 'reliability-incident-response',
  },
  {
    id: 'pps-rel-4',
    text: 'When debugging a production regression, a strong first step is:',
    options: ['Change multiple components at once', 'Compare recent changes and telemetry around the failure window', 'Wipe all caches without evidence', 'Disable logs for performance'],
    correctAnswer: 1,
    explanation: 'Time-bounded change correlation and telemetry inspection speed up root-cause isolation.',
    difficulty: 'medium',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'real_world_execution',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'production-problem-solving',
    lessonId: 'reliability-incident-response',
  },
  {
    id: 'pps-rel-5',
    text: 'Why is runbook quality important in operations?',
    options: ['It reduces the need for metrics', 'It standardizes incident response and lowers time-to-mitigate', 'It replaces architecture diagrams', 'It prevents all outages'],
    correctAnswer: 1,
    explanation: 'Clear runbooks reduce confusion and improve consistency under operational pressure.',
    difficulty: 'hard',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'real_world_execution',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'production-problem-solving',
    lessonId: 'reliability-incident-response',
  },

  // Lesson: cross-functional-execution
  {
    id: 'pps-cfx-1',
    text: 'When multiple teams depend on one delivery, the best planning approach is:',
    options: ['Independent timelines with no checkpoints', 'Shared milestones, owners, risks, and communication cadence', 'Only ad-hoc messaging', 'One final sync at launch'],
    correctAnswer: 1,
    explanation: 'Cross-functional programs succeed with explicit ownership, dependencies, and recurring alignment.',
    difficulty: 'medium',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'real_world_execution',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'production-problem-solving',
    lessonId: 'cross-functional-execution',
  },
  {
    id: 'pps-cfx-2',
    text: 'A good way to prioritize backlog items with limited capacity is:',
    options: ['Oldest ticket first always', 'Impact, urgency, effort, and risk-based prioritization', 'Highest word-count requirement first', 'Random selection each sprint'],
    correctAnswer: 1,
    explanation: 'Structured prioritization improves ROI and reduces context switching.',
    difficulty: 'easy',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'real_world_execution',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'production-problem-solving',
    lessonId: 'cross-functional-execution',
  },
  {
    id: 'pps-cfx-3',
    text: 'If a release is blocked by a critical dependency, the most practical response is:',
    options: ['Hide the blocker from stakeholders', 'Escalate early, propose options, and align on tradeoffs', 'Wait silently for resolution', 'Start unrelated refactoring'],
    correctAnswer: 1,
    explanation: 'Early communication with viable options enables faster and better decision-making.',
    difficulty: 'medium',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'real_world_execution',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'production-problem-solving',
    lessonId: 'cross-functional-execution',
  },
  {
    id: 'pps-cfx-4',
    text: 'A clear launch readiness review should include:',
    options: ['Only feature demos', 'Rollback plan, ownership, metrics, and support readiness', 'No on-call assignment', 'Skipping risk assessment'],
    correctAnswer: 1,
    explanation: 'Launch quality depends on operational readiness, not just feature completeness.',
    difficulty: 'hard',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'real_world_execution',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'production-problem-solving',
    lessonId: 'cross-functional-execution',
  },
  {
    id: 'pps-cfx-5',
    text: 'What is a healthy default when choosing between speed and reliability?',
    options: ['Always maximize speed', 'Always maximize reliability regardless context', 'Choose by risk tier and user impact with explicit tradeoff', 'Delay all launches indefinitely'],
    correctAnswer: 2,
    explanation: 'Balanced decisions require context, risk assessment, and transparent tradeoffs.',
    difficulty: 'hard',
    roles: ['data_scientist', 'ml_engineer', 'ai_engineer', 'mlops_engineer'],
    category: 'real_world_execution',
    companySizes: ['startup', 'midsize', 'large', 'faang'],
    unitId: 'production-problem-solving',
    lessonId: 'cross-functional-execution',
  },
];
